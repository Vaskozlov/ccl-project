#include <ast-lang-2/ast-lang.hpp>

namespace astlang2
{
    constexpr isl::string_view AstLangGrammar = R"(
%PARSER%

GOAL:
    GLOBAL_DECLARATIONS

GLOBAL_DECLARATIONS:
    GLOBAL_DECLARATION GLOBAL_DECLARATIONS
    | GLOBAL_DECLARATION
    | EPSILON

GLOBAL_DECLARATION:
    FUNCTION_DEFINITION
    | PARSER_RULE
    | LEXER_RULE
    | STATEMENT

LEXER_RULE:
    "lexer" IDENTIFIER
    '{'
        LEXER_RULE_BODY
    '}'

LEXER_RULE_BODY:
    LEXER_RULE_BODY ',' EXPRESSION
    | EXPRESSION
    | EPSILON

PARSER_RULE:
    "parser" IDENTIFIER
    '{'
        PARSER_RULE_BODY
    '}'

PARSER_RULE_BODY:
    PARSER_SYMBOLS ';' PARSER_FUNCTIONS

PARSER_FUNCTIONS:
    PARSER_FUNCTIONS FUNCTION_DEFINITION
    | FUNCTION_DEFINITION
    | EPSILON

PARSER_SYMBOLS:
    PARSER_SYMBOLS ',' EXPRESSION
    | EXPRESSION
    | EPSILON

FUNCTION_DEFINITION:
    "def" IDENTIFIER '(' FUNCTION_DEFINITION_ARGUMENTS ')' FUNCTION_RETURN_TYPE
    '{'
        STATEMENTS
    '}'

FUNCTION_DEFINITION_ARGUMENTS:
    FUNCTION_DEFINITION_ARGUMENT ',' FUNCTION_DEFINITION_ARGUMENTS
    | FUNCTION_DEFINITION_ARGUMENT
    | EPSILON

FUNCTION_DEFINITION_ARGUMENT:
    TYPE IDENTIFIER

FUNCTION_RETURN_TYPE:
    '->' TYPE
    | EPSILON

STATEMENTS:
    STATEMENT STATEMENTS
    | STATEMENT
    | EPSILON

STATEMENT:
    ASSIGNMENT_EXPRESSION ';'
    | VARIABLE_DECLARATION ';'
    | TYPE_VARIABLE_DECLARATION ';'
    | FOR_LOOP
    | WHILE_LOOP
    | IF_STATEMENT
    | RETURN_STATEMENT ';'

RETURN_STATEMENT:
    "return" ASSIGNMENT_EXPRESSION
    | "return"

IF_STATEMENT:
    IF_BLOCK
    ELIF_BLOCK
    ELSE_BLOCK

IF_BLOCK:
    "if" ASSIGNMENT_EXPRESSION
    '{'
        STATEMENTS
    '}'

ELIF_BLOCK:
    "elif" ASSIGNMENT_EXPRESSION
    '{'
        STATEMENTS
    '}'
    ELIF_BLOCK
    | EPSILON

ELSE_BLOCK:
    "else"
    '{'
        STATEMENTS
    '}'
    | EPSILON

ASSIGNMENT_EXPRESSION:
    LOGICAL_OR_EXPRESSION '=' ASSIGNMENT_EXPRESSION
    | LOGICAL_OR_EXPRESSION

LOGICAL_OR_EXPRESSION:
    LOGICAL_OR_EXPRESSION '||' LOGICAL_AND_EXPRESSION
    | LOGICAL_AND_EXPRESSION

LOGICAL_AND_EXPRESSION:
    LOGICAL_AND_EXPRESSION '&&' BITWISE_OR_EXPRESSION
    | BITWISE_OR_EXPRESSION

BITWISE_OR_EXPRESSION:
    BITWISE_OR_EXPRESSION '|' BITWISE_XOR_EXPRESSION
    | BITWISE_XOR_EXPRESSION

BITWISE_XOR_EXPRESSION:
    BITWISE_XOR_EXPRESSION '^' BITWISE_AND_EXPRESSION
    | BITWISE_AND_EXPRESSION

BITWISE_AND_EXPRESSION:
    BITWISE_AND_EXPRESSION '&' EQUALITY
    | EQUALITY

EQUALITY:
    EQUALITY '==' COMPARISON
    | EQUALITY '!=' COMPARISON
    | COMPARISON

COMPARISON:
    COMPARISON '<' EXPRESSION
    | COMPARISON '>' EXPRESSION
    | COMPARISON '<=' EXPRESSION
    | COMPARISON '>=' EXPRESSION
    | EXPRESSION

EXPRESSION:
    EXPRESSION '+' TERM
    | EXPRESSION '-' TERM
    | TERM

TERM:
    TERM '*' VALUE
    | TERM '/' VALUE
    | VALUE

VALUE:
    '-' VALUE
    | '+' VALUE
    | FACTOR

VARIABLE_DECLARATION:
    "var" IDENTIFIER '=' ASSIGNMENT_EXPRESSION

TYPE_VARIABLE_DECLARATION:
    "var" IDENTIFIER ':' TYPE '=' ASSIGNMENT_EXPRESSION

FOR_LOOP:
    "for" IDENTIFIER "in" ASSIGNMENT_EXPRESSION
    '{'
        STATEMENTS
    '}'

WHILE_LOOP:
    "while" ASSIGNMENT_EXPRESSION
    '{'
        STATEMENTS
    '}'

FUNCTION_CALL:
    IDENTIFIER '(' FUNCTION_CALL_ARGUMENTS ')'

FUNCTION_CALL_ARGUMENTS:
    ASSIGNMENT_EXPRESSION ',' FUNCTION_CALL_ARGUMENTS
    | ASSIGNMENT_EXPRESSION
    | EPSILON

METHOD_CALL:
    FACTOR '.' IDENTIFIER '(' FUNCTION_CALL_ARGUMENTS ')'

FACTOR:
    NUMBER
    | FLOAT
    | ARRAY
    | "true"
    | "false"
    | IDENTIFIER
    | STRING
    | FUNCTION_CALL
    | METHOD_CALL
    | '(' ASSIGNMENT_EXPRESSION ')'

ARRAY:
    '[' ARRAY_ELEMENTS ']'

ARRAY_ELEMENTS:
    ASSIGNMENT_EXPRESSION ',' ARRAY_ELEMENTS
    | ASSIGNMENT_EXPRESSION

TYPE:
    IDENTIFIER
    | IDENTIFIER '<' TYPE '>'

%LEXER%
IDENTIFIER: [a-zA-Z_] [a-zA-Z0-9_]*
FLOAT:      [0-9]+[.][0-9]+
NUMBER:     [0-9]+
STRING:     ! ["] ("\\\"" | ["]^)* ["]
)";
}